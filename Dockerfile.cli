# syntax=docker/dockerfile:1

# Control plane CLI tools for EJFAT (Optimized)
#
# This is a multi-stage build optimized for smaller final image size:
#   - base-runtime: Minimal dependencies for running the application
#   - base-build: Adds build tools (example for compiling from source)
#   - compile: Builds the application
#   - deploy: Final slim image
#   - deploy-debug: Optional variant with network debugging tools
#
# Build commands:
#   Production:  docker build --target deploy -t e2sar-utils:slim -f Dockerfile.cli .
#   Debug:       docker build --target deploy-debug -t e2sar-utils:debug -f Dockerfile.cli .
#   Build stage: docker build --target compile -t e2sar-utils:build -f Dockerfile.cli .

#
# Stage 'base-runtime': Minimal runtime dependencies
#
FROM ubuntu:24.04 AS base-runtime

ENV DISTRO=ubuntu24
ENV HOME=/home/ubuntu
ENV LD_LIBRARY_PATH=/usr/local/lib
ENV PKG_CONFIG_PATH=/usr/local/lib/pkgconfig
ENV PATH=/usr/local/bin:$PATH
ENV E2SARINSTALL=/e2sar-install
ENV E2SAR_VER=0.3.0a1
ENV E2SAR_DEB=E2SAR-${E2SAR_VER}-main-ubuntu-24.04/e2sar_${E2SAR_VER}_amd64.deb
ENV E2SAR_DEB_URL=https://github.com/JeffersonLab/E2SAR/releases/download/${E2SAR_DEB}
ENV ROOT_INSTALL=/rootlib
ENV ROOT_VER=6.36.06
ENV ROOT_TAR=root_v${ROOT_VER}.Linux-ubuntu24.04-x86_64-gcc13.3.tar.gz
ENV ROOT_URL=https://root.cern/download/${ROOT_TAR}

RUN mkdir ${E2SARINSTALL} && mkdir ${ROOT_INSTALL}

# Runtime dependencies only (libraries needed by ROOT and E2SAR at runtime)
RUN apt-get -yq update && \
    apt-get -yq install --no-install-recommends \
        ca-certificates \
        openssl \
        libre2-dev \
        libtbb12 \
        libvdt0.4 \
        libgif7 \
        libx11-6 \
        libxext6 \
        libxft2 \
        libxpm4 && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Install E2SAR from pre-built .deb package
RUN apt-get -yq update && \
    apt-get -yq install --no-install-recommends wget && \
    wget -q -O e2sar.deb ${E2SAR_DEB_URL} && \
    dpkg -i ./e2sar.deb && \
    rm e2sar.deb && \
    apt-get -yq purge wget && \
    apt-get -yq autoremove && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Install ROOT (pre-built binary distribution)
RUN apt-get -yq update && \
    apt-get -yq install --no-install-recommends wget && \
    wget -q -O root.tar.gz ${ROOT_URL} && \
    tar -zxf root.tar.gz -C ${ROOT_INSTALL} && \
    rm root.tar.gz && \
    apt-get -yq purge wget && \
    apt-get -yq autoremove && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

#
# Stage 'base-build': Adds build tools for compilation
#
# This stage demonstrates all dependencies needed to compile the code from source.
# It extends base-runtime with build-time dependencies.
#
FROM base-runtime AS base-build

# Build system and compilation dependencies
# - build-essential: gcc, g++, make, etc.
# - meson/ninja: Build system used by this project
# - cmake: Required by some dependencies
# - pkg-config: For finding installed libraries
# - protobuf-compiler: For E2SAR gRPC communication
# - gdb: Debugger (optional, useful during development)
RUN apt-get -yq update && \
    apt-get -yq install \
        python3-pip \
        build-essential \
        autoconf \
        cmake \
        libtool \
        pkg-config \
        libglib2.0-dev \
        ninja-build \
        libssl-dev \
        libsystemd-dev \
        protobuf-compiler \
        gdb \
        wget && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Python build tools
# - meson: Build system
# - pybind11: Python bindings (if needed)
RUN pip3 install --break-system-packages pybind11 meson

#
# Stage 'compile': Build the application from source
#
FROM base-build AS compile

ENV SRC_DIR=/src
ENV CODA=/src/coda
WORKDIR $SRC_DIR

# Copy source code
COPY . /src/

# Configure and build
# 1. Source ROOT environment (thisroot.sh sets up ROOT paths)
# 2. Run meson setup to configure the build
# 3. Fix C++ standard flag conflict (ROOT uses newer standard)
# 4. Compile with meson
# 5. Install to E2SARINSTALL prefix
RUN cd ${ROOT_INSTALL}/root/bin && \
    . ./thisroot.sh && \
    cd ${SRC_DIR} && \
    PATH=$HOME/.local/bin:/usr/local/bin:$PATH \
    BOOST_ROOT=/usr/local/ \
    LD_LIBRARY_PATH=${LD_LIBRARY_PATH} \
    meson setup -Dpkg_config_path=${PKG_CONFIG_PATH} --prefix ${E2SARINSTALL} build && \
    sed -i 's/-std=c++11//g' build/build.ninja && \
    meson compile -C build -j 2 && \
    meson install -C build

#
# Stage 'deploy': Final slim production image
#
# This stage contains only what's needed to run the application:
# - Runtime libraries (from base-runtime)
# - Compiled application binaries
# - Complete source directory with coda/, ersap/, and all dependencies
#
FROM base-runtime AS deploy

# Set MACHINE environment variable for env.sh
ENV MACHINE=Linux-x86_64

# Set working directory for packaged tools
ENV WORKDIR=/work
WORKDIR ${WORKDIR}

# Set CODA environment variable to point to coda directory
ENV CODA=${WORKDIR}/coda

# Update PATH to include E2SAR, CODA, and ERSAP binaries
ENV PATH=${E2SARINSTALL}/bin:${WORKDIR}/coda/${MACHINE}/bin:${WORKDIR}/coda/common/bin:${WORKDIR}/ersap/bin:$PATH

# Update LD_LIBRARY_PATH to include CODA libraries for ET shared objects
ENV LD_LIBRARY_PATH=${WORKDIR}/coda/${MACHINE}/lib:/usr/local/lib

# ROOT's cling interpreter needs C++ standard library headers at runtime
# Install them here (not in base-runtime to avoid conflicts with base-build)
RUN apt-get -yq update && \
    apt-get -yq install --no-install-recommends \
        libstdc++-13-dev && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Copy only the compiled application from the compile stage
COPY --from=compile $E2SARINSTALL $E2SARINSTALL

# Copy entire build context (coda/, ersap/, env.sh, etc.) to /work
COPY . ${WORKDIR}/

# Create ersap-data directory if it doesn't exist
RUN mkdir -p ${WORKDIR}/ersap-data

# Copy and set up entrypoint script
COPY entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh

# Expose ET port
EXPOSE 23911

ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]

#
# Stage 'deploy-debug': Optional debug variant with network tools
#
# Use this image when you need to debug network issues or inspect traffic.
# Build with: docker build --target deploy-debug -t e2sar-utils:debug -f Dockerfile.cli .
#
FROM deploy AS deploy-debug

RUN apt-get -yq update && \
    apt-get -yq install --no-install-recommends \
        netcat-traditional \
        net-tools \
        bc \
        ethtool \
        iproute2 \
        iputils-ping \
        nano \
        tcpdump \
        python3-pip && \
    pip3 install --break-system-packages scapy && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# deploy-debug uses the same ENTRYPOINT as deploy
